"use strict";(self.webpackChunksteebe_dev=self.webpackChunksteebe_dev||[]).push([[553],{5766:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var l=t(8453),a=t(6540);function o(e){const n=Object.assign({h1:"h1",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li"},(0,l.RP)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h1,null,"MySQL - Helpful Tidbits"),"\n",a.createElement(n.p,null,"My experiences at Rev360 (RevolutionEHR) and Mercato brought about developing for back-ends that leverage MySQL for data storage solutions. All my other previous experiences were within the context of Oracle, DB2, and SQL Server database technologies, and I found myself constantly Googling to see how to do things better in MySQL. Below are some of those findings."),"\n",a.createElement(n.h2,null,"Perform batch UPDATEs with a temp table"),"\n",a.createElement(n.p,null,"When performing ",a.createElement(n.code,null,"UPDATE"),"s against a table in bulk, MySQL is pretty non-performant when given a raw ",a.createElement(n.code,null,"UPDATE")," statement with a ",a.createElement(n.code,null,"WHERE")," clause:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"UPDATE A\nSET foo = 'bar' WHERE id < 1000;\n")),"\n",a.createElement(n.p,null,"The best way of handling bulk ",a.createElement(n.code,null,"UPDATE"),"s turns out to be establishing a temp table containing the values that encapsulate the data for the ",a.createElement(n.code,null,"UPDATE"),", and then performing the ",a.createElement(n.code,null,"UPDATE")," with a ",a.createElement(n.code,null,"JOIN")," against the temporary table."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"DROP TABLE IF EXISTS `tempFooValues`;\n\nCREATE TABLE `tempFooValues` (\n`id` INT(11) UNSIGNED NOT NULL,\n`foo` VARCHAR(255) NOT NULL,\nPRIMARY KEY(`id`)\n);\n\nINSERT INTO tempFooValues (id, foo) VALUES\n(1, 'bar'),\n(2, 'bar'),\n...,\n...,\n(1000, 'bar');\n\nUPDATE A\nINNER JOIN tempFooValues ON tempFooValues.id = A.id\nSET\nA.foo = tempFooValues.foo;\n")),"\n",a.createElement(n.h2,null,"Leveraging CASE within a JOIN"),"\n",a.createElement(n.p,null,"This one is pretty self-explanatory..."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT * FROM A\nJOIN B\nON CASE\nWHEN B.type IN (1, 3) AND B.a_id = A.id THEN 1\nWHEN B.type IN (2) AND B.other_id = A.other_id THEN 1\nELSE 0\nEND = 1;\n")),"\n",a.createElement(n.h2,null,"Converting Timezones from UTC"),"\n",a.createElement(n.p,null,'The arguments for the "from" and "to" timezones in ',a.createElement(n.code,null,"CONVERT_TZ")," are the offsets from\nUTC. Therefore, ",a.createElement(n.code,null,"+00:00")," is itself UTC, and ",a.createElement(n.code,null,"-07:00")," would equate to PT in the U.S."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT CONVERT_TZ(created, '+00:00','-07:00') FROM users;\n")),"\n",a.createElement(n.h2,null,"Performing Maintenance on Huge Tables"),"\n",a.createElement(n.p,null,"Old faithful has been holding down the fort for 9 years. It's full of juicy data that's\nboth important for reporting and critical for application business logic for end users.\nIt is also missing a ton of helpful index values underneath the columns matter most."),"\n",a.createElement(n.p,null,"Your reports won't report, and you know in your gut that ",a.createElement(n.code,null,"ALTER TABLE")," in real time on\nold faithful will take about 10,000 years to execute."),"\n",a.createElement(n.p,null,"So, you perform the following:"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Create a new table that contains the index values you require"),"\n",a.createElement(n.li,null,"Copy the data from old faithful into this clone table with indices"),"\n",a.createElement(n.li,null,"Rename (or drop) the original old faithful, and rename the clone to become old faithful"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"BEGIN;\n\nCREATE TABLE IF NOT EXISTS oldFaithfulWithIndices LIKE oldFaithful;\n\nALTER TABLE oldFaithfulWithIndices\n    ADD INDEX `account_id_index`(`account_id`),\n    ADD INDEX `email_address_index`(`email_address`),\n    ADD INDEX `created_datetime_index`(`created_datetime`),\n    ADD INDEX `updated_datetime_index`(`updated_datetime`);\n\nINSERT INTO oldFaithfulWithIndices SELECT * FROM oldFaithful;\n\nRENAME TABLE oldFaithful TO oldFaithful_archive;\n\nRENAME TABLE oldFaithfulWithIndices TO oldFaithful;\n\nCOMMIT;\n")),"\n",a.createElement(n.h2,null,"Adding composite unique indexes to existing table"),"\n",a.createElement(n.p,null,"When working with a table that already contains data that would violate a desired ",a.createElement(n.code,null,"unique")," index\nyou wish to apply to a table, it's important you scrub the dupes."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"DELETE FROM my_table\nWHERE id NOT IN (\n    SELECT MIN(id)\n    FROM my_table\n    GROUP BY col_1, col_2\n)\nAND (col_1, col_2) in (\n    SELECT col_1, col_2\n    FROM my_table\n    GROUP BY col_1, col_2\n    HAVING count(*) > 1\n);\n")),"\n",a.createElement(n.h2,null,"GROUP_CONCAT()"),"\n",a.createElement(n.p,null,"The ",a.createElement(n.code,null,"GROUP_CONCAT()")," function is used to aggregate the results of a column into a single field."),"\n",a.createElement(n.p,null,"Use cases..."),"\n",a.createElement(n.p,null,"Concatenating all single-column results into a single field results:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT GROUP_CONCAT(email_address) FROM customer; \n")),"\n",a.createElement(n.p,null,"Grouping all results of a column into a single field relative to a shared group identifier"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT customer, GROUP_CONCAT(order.id)\nFROM customer\nJOIN order ON customer.id = order.customer_id\nGROUP BY customer.id\n")),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"GROUP_CONCAT()")," allows for customizability of the structure of the aggregated data:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT customer, GROUP_CONCAT(order.id ORDER BY order.id DESC SEPARATOR '| ')\nFROM customer\nJOIN order ON customer.id = order.customer_id\nGROUP BY customer.id\n")),"\n",a.createElement(n.h2,null,a.createElement(n.code,null,"LAST_INSERT_ID()")),"\n",a.createElement(n.p,null,"For any given session in the database engine, the session user can inspect their latest insertion ID with:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-sql"},"SELECT LAST_INSERT_ID();\n")),"\n",a.createElement(n.p,null,"This function operates on a per-connection basis, meaning that when the DB session user terminates their\ncurrent connection, their next session will yield a different result. A fresh session yields ",a.createElement(n.code,null,"0"),"."))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.RP)(),e.components);return n?a.createElement(n,e,a.createElement(o,e)):o(e)},i=t(1633),c=t(5999);const s=e=>{let{data:n,children:t}=e;return a.createElement(i.A,null,a.createElement("p",{className:c.p6},a.createElement("i",null,n.mdx.frontmatter.date),a.createElement("br",null),n.mdx.frontmatter.updated&&a.createElement("i",null,"(Updated on ",n.mdx.frontmatter.updated,")")),a.createElement("div",{className:c.bE},t))};function u(e){return a.createElement(s,e,a.createElement(r,e))}},5999:function(e,n,t){t.d(n,{bE:function(){return a},p6:function(){return l}});var l="lines-module--date--99f4f",a="lines-module--post--c3f31"},8453:function(e,n,t){t.d(n,{RP:function(){return o}});var l=t(6540);const a=l.createContext({});function o(e){const n=l.useContext(a);return l.useMemo(()=>"function"==typeof e?e(n):{...n,...e},[n,e])}}}]);
//# sourceMappingURL=component---src-pages-lines-mdx-fields-slug-tsx-content-file-path-blog-mysql-tips-and-tricks-mdx-555779cd348f4da4a8d7.js.map